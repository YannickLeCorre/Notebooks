[
["index.html", "R Notebooks in a book Preface", " R Notebooks in a book Yannick Le Corre 2019-02-01 Preface TODO "],
["r-language.html", "Chapter 1 R language 1.1 R conference 2018 1.2 Sams Teach Yourself R 1.3 Advanced R", " Chapter 1 R language 1.1 R conference 2018 by Emily Robinson (DataCamp) at the 2018 New York R Conference Les packages de l’écosystème tidyverse sont décrits dans le diagramme 1. Noter que leaflet ne fait pas partie de tidyverse. library(tidyverse) tidyverse_packages() ## [1] &quot;broom&quot; &quot;cli&quot; &quot;crayon&quot; &quot;dplyr&quot; &quot;dbplyr&quot; ## [6] &quot;forcats&quot; &quot;ggplot2&quot; &quot;haven&quot; &quot;hms&quot; &quot;httr&quot; ## [11] &quot;jsonlite&quot; &quot;lubridate&quot; &quot;magrittr&quot; &quot;modelr&quot; &quot;purrr&quot; ## [16] &quot;readr&quot; &quot;readxl\\n(&gt;=&quot; &quot;reprex&quot; &quot;rlang&quot; &quot;rstudioapi&quot; ## [21] &quot;rvest&quot; &quot;stringr&quot; &quot;tibble&quot; &quot;tidyr&quot; &quot;xml2&quot; ## [26] &quot;tidyverse&quot; data anlysis workflow (draw.io) 1.1.1 make a toy dataset library(tibble) df &lt;- tribble( ~date, ~whatever, ~numstuff1, ~numstuff2, ~multi_value, &quot;10-09-2017&quot;, .1, 5, NA, &quot;val1, val2, val3&quot;, &quot;10-09-2017&quot;, .5, 1, 3, &quot;val1&quot;, &quot;11-09-2017&quot;, .2, 3, 2, &quot;val1, val2&quot;, &quot;12-09-2017&quot;, .5, Inf, 3, &quot;val1, val2, val3, val4&quot; ) df ## # A tibble: 4 x 5 ## date whatever numstuff1 numstuff2 multi_value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 10-09-2017 0.1 5 NA val1, val2, val3 ## 2 10-09-2017 0.5 1 3 val1 ## 3 11-09-2017 0.2 3 2 val1, val2 ## 4 12-09-2017 0.5 Inf 3 val1, val2, val3, val4 Examine your NAs and empty values library(purrr) df %&gt;% purrr::map_df(~sum(is.na(.))) # count the NA for every columns of a DF ## # A tibble: 1 x 5 ## date whatever numstuff1 numstuff2 multi_value ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 0 0 0 1 0 library(dplyr) df &lt;- df %&gt;% na_if(Inf) # convert empty values into NA values df ## # A tibble: 4 x 5 ## date whatever numstuff1 numstuff2 multi_value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 10-09-2017 0.1 5 NA val1, val2, val3 ## 2 10-09-2017 0.5 1 3 val1 ## 3 11-09-2017 0.2 3 2 val1, val2 ## 4 12-09-2017 0.5 NA 3 val1, val2, val3, val4 1.1.2 Examine your numeric columns library(skimr) df %&gt;% select_if(is.numeric) %&gt;% skimr::skim() # summary of all the numeric columns ## Skim summary statistics ## n obs: 4 ## n variables: 3 ## ## -- Variable type:numeric ---------------------------------------------------------- ## variable missing complete n mean sd p0 p25 p50 p75 p100 hist ## numstuff1 1 3 4 3 2 1 2 3 4 5 &lt;U+2587&gt;&lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2587&gt;&lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2587&gt; ## numstuff2 1 3 4 2.67 0.58 2 2.5 3 3 3 &lt;U+2583&gt;&lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2587&gt; ## whatever 0 4 4 0.32 0.21 0.1 0.18 0.35 0.5 0.5 &lt;U+2583&gt;&lt;U+2583&gt;&lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2581&gt;&lt;U+2587&gt; 1.1.3 Tidy columns containing colon separated values library(tidyr) library(stringr) df &lt;- df %&gt;% mutate(colonne = str_split(multi_value, &quot;,&quot;)) %&gt;% # transform into a list of characters unnest() # split into seperate observations 1.1.4 plot uncluttered bar charts library(ggplot2) library(forcats) df %&gt;% count(date) %&gt;% mutate(date = fct_reorder(date, n)) %&gt;% # ordonne les colonnes en ordre décroissant ggplot(aes(x = date, y = n)) + geom_col() + coord_flip() 1.2 Sams Teach Yourself R By Andy Nicholls, Richard Pugh, &amp; Aimee Gott (first edition dec 2015) object types 4 modes (fonction mode()): numeric character boolean complex 3 types (fonction class()): vector (c’est le type de base) - attributes length et names matrix/array - attribut dim list 1.2.1 cut et split cut est utilisé pour classer des donnÃ©es numÃ©riques en facteur numeric_matrix &lt;- 1:100 mycut1 &lt;- cut(numeric_matrix, 3) # classifie les données selon trois classes de valeurs égales head(mycut1) ## [1] (0.901,34] (0.901,34] (0.901,34] (0.901,34] (0.901,34] (0.901,34] ## Levels: (0.901,34] (34,67] (67,100] table(mycut1) ## mycut1 ## (0.901,34] (34,67] (67,100] ## 34 33 33 On peut aussi couper selon des classes numÃ©riques spÃ©cifiques mycut2 &lt;- cut(numeric_matrix, breaks = c(1, 10, 100), include.lowest = TRUE) # classes [1, 10], ]10, 100] head(mycut2) ## [1] [1,10] [1,10] [1,10] [1,10] [1,10] [1,10] ## Levels: [1,10] (10,100] table(mycut2) ## mycut2 ## [1,10] (10,100] ## 10 90 La fonction split permet de découper un ensemble selon des facteurs. Donc on peut combiner les fonctions cut et split pour décomposer un vecteur ou DF en liste de vecteurs/DF groupées par facteur. mysplit_list &lt;- split(numeric_matrix, mycut2) la fonction split fonctionne aussi sur des DF df &lt;- data.frame(value = sample(1:1000, size = 100), whatever = LETTERS[sample(1:length(LETTERS), size = 100, replace=TRUE)]) split(df, cut(df$value, 3)) ## $`(7.01,339]` ## value whatever ## 2 255 Y ## 5 310 X ## 6 274 E ## 9 182 T ## 16 283 A ## 18 208 W ## 26 8 Q ## 31 69 W ## 32 188 L ## 34 285 Y ## 35 55 M ## 36 45 K ## 37 306 Z ## 40 65 A ## 43 103 H ## 44 125 I ## 46 234 K ## 52 14 Y ## 54 71 S ## 57 99 K ## 60 21 G ## 66 296 D ## 68 176 G ## 69 170 V ## 71 57 O ## 76 335 I ## 82 200 W ## 84 68 N ## 86 59 P ## 87 100 C ## 88 185 H ## 91 89 K ## 92 11 N ## 96 268 M ## 100 63 C ## ## $`(339,669]` ## value whatever ## 1 512 N ## 4 669 K ## 7 412 R ## 12 593 F ## 17 467 D ## 20 435 A ## 23 352 H ## 24 339 V ## 27 577 S ## 29 664 F ## 30 646 P ## 39 553 V ## 47 617 G ## 49 571 A ## 55 456 M ## 56 369 S ## 59 661 N ## 63 592 D ## 65 652 T ## 72 645 E ## 77 575 O ## 78 413 F ## 81 472 V ## 83 432 F ## 85 598 C ## 90 510 F ## 95 551 Z ## 98 499 K ## ## $`(669,1e+03]` ## value whatever ## 3 937 A ## 8 805 P ## 10 811 A ## 11 711 P ## 13 1000 D ## 14 974 Y ## 15 917 V ## 19 782 P ## 21 900 R ## 22 913 G ## 25 978 D ## 28 705 D ## 33 976 P ## 38 723 Q ## 41 942 O ## 42 732 A ## 45 987 C ## 48 674 Z ## 50 721 K ## 51 983 O ## 53 794 T ## 58 710 U ## 61 877 U ## 62 848 A ## 64 908 W ## 67 783 O ## 70 730 H ## 73 726 G ## 74 969 L ## 75 874 U ## 79 952 P ## 80 970 E ## 89 881 T ## 93 719 Z ## 94 745 X ## 97 670 S ## 99 941 U 1.3 Advanced R The book Advanced R explains a lot of fundamental aspects of the R language. The library lobstr allows to check the size of a variable library(lobstr) obj_size(1) ## 56 B Main object types t1 &lt;- c(1:5) show_type(t1) ## [1] 1 2 3 4 5 ## [1] &quot;integer&quot; ## int [1:5] 1 2 3 4 5 t2 &lt;- c(1.1, 1e2) show_type(t2) ## [1] 1.1 100.0 ## [1] &quot;double&quot; ## num [1:2] 1.1 100 t3 &lt;- c(&quot;dog&quot;, &quot;cat&quot;) show_type(t3) ## [1] &quot;dog&quot; &quot;cat&quot; ## [1] &quot;character&quot; ## chr [1:2] &quot;dog&quot; &quot;cat&quot; t4 &lt;- c(TRUE, FALSE) show_type(t4) ## [1] TRUE FALSE ## [1] &quot;logical&quot; ## logi [1:2] TRUE FALSE t5 &lt;- list(1:2, 2:3) show_type(t5) ## [[1]] ## [1] 1 2 ## ## [[2]] ## [1] 2 3 ## ## [1] &quot;list&quot; ## List of 2 ## $ : int [1:2] 1 2 ## $ : int [1:2] 2 3 t6 &lt;- data.frame(col1 = c(1:5), col2 = letters[1:5]) show_type(t6) ## col1 col2 ## 1 1 a ## 2 2 b ## 3 3 c ## 4 4 d ## 5 5 e ## [1] &quot;list&quot; ## &#39;data.frame&#39;: 5 obs. of 2 variables: ## $ col1: int 1 2 3 4 5 ## $ col2: Factor w/ 5 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5 "],
["resume-analysis.html", "Chapter 2 Resume_analysis", " Chapter 2 Resume_analysis knitr::opts_chunk$set(warning=FALSE, message=FALSE, include=TRUE) DATASET_DIRECTORY &lt;- &quot;./DATA/&quot; ##CV &lt;- &quot;2019_last.docx&quot; ##LANGUE &lt;- &quot;en&quot; CV &lt;- &quot;ébauche_v5.docx&quot; LANGUE &lt;- &quot;fr&quot; FILENAME &lt;- paste(getwd(), DATASET_DIRECTORY, CV, sep=&quot;&quot;) Filtre des occurences &gt; \\(3\\) "],
["running.html", "Chapter 3 running", " Chapter 3 running knitr::opts_chunk$set(warning=FALSE, message=FALSE, include=TRUE) library(knitr) library(xml2) library(tidyverse) DATASET_DIRECTORY &lt;- &quot;/DATASETS/smashrun/RAW.unzipped&quot; setwd(DATASET_DIRECTORY) file_list &lt;- dir() The raw data is located in the directory: /DATASETS/smashrun/RAW.unzipped and comprises \\(979\\) files testFileName &lt;- file_list[1] setwd(DATASET_DIRECTORY) out &lt;- readLines(testFileName, n=-1) # read all the lines of the file into a vector of characters library(stringr) toto &lt;- str_c(out, collapse = &quot;&quot;) # concatenate all the lines into one line test &lt;- read_xml(toto, as_html = FALSE, options = c(&quot;NOBLANKS&quot;,&quot;RECOVER&quot;), verbose=TRUE) Validation against the XMLschema Here is the header of a sample file: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;TrainingCenterDatabase creator=&quot;Smashrun&quot; xsi:schemaLocation=&quot;http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2 http://www.garmin.com/xmlschemas/TrainingCenterDatabasev2.xsd&quot; xmlns:ns5=&quot;http://www.garmin.com/xmlschemas/ActivityGoals/v1&quot; xmlns:ns3=&quot;http://www.garmin.com/xmlschemas/ActivityExtension/v2&quot; xmlns:ns2=&quot;http://www.garmin.com/xmlschemas/UserProfile/v2&quot; xmlns=&quot;http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:ns4=&quot;http://www.garmin.com/xmlschemas/ProfileExtension/v1&quot;&gt; schema &lt;- read_xml(&quot;http://www.garmin.com/xmlschemas/TrainingCenterDatabasev2.xsd&quot;) xml_validate(test, schema) ## [1] FALSE ## attr(,&quot;errors&quot;) ## [1] &quot;Element &#39;{http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2}TrainingCenterDatabase&#39;, attribute &#39;creator&#39;: The attribute &#39;creator&#39; is not allowed.&quot; ## [2] &quot;Element &#39;{http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2}Intensity&#39;: This element is not expected. Expected is ( {http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2}Calories ).&quot; ## [3] &quot;Element &#39;{http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2}Author&#39;: Missing child element(s). Expected is ( {http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2}LangID ).&quot; On voit quelques écarts mais ce n’est pas un indicateur de mauvaise qualité des données (ie information manquante, érronée, etc…) 3.0.1 Étude du schéma L’emplacement du schéma à changé d’emplacement : yannick@debian:~$ curl https://www.garmin.com/xmlschemas/TrainingCenterDatabasev2.xsd &lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt; &lt;html&gt;&lt;head&gt; &lt;title&gt;301 Moved Permanently&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;h1&gt;Moved Permanently&lt;/h1&gt; &lt;p&gt;The document has moved &lt;a href=&quot;http://www8.garmin.com/xmlschemas/TrainingCenterDatabasev2.xsd&quot;&gt;here&lt;/a&gt;.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; Il peut-être téléchargé via la nouvelle URL: yannick@debian:~$ curl https://www8.garmin.com/xmlschemas/TrainingCenterDatabasev2.xsd ## Exract the root node form the xml file. rootnode &lt;- xml_root(test) mode(rootnode) ## [1] &quot;list&quot; str(rootnode) ## List of 2 ## $ node:&lt;externalptr&gt; ## $ doc :&lt;externalptr&gt; ## - attr(*, &quot;class&quot;)= chr [1:2] &quot;xml_document&quot; &quot;xml_node&quot; ## Find number of nodes in the root. rootsize &lt;- xml_length(rootnode) ## Print the result. print(rootsize) ## [1] 2 noeud racine child1 &lt;- xml_child(rootnode, 1) mode(child1) ## [1] &quot;list&quot; str(child1) ## List of 2 ## $ node:&lt;externalptr&gt; ## $ doc :&lt;externalptr&gt; ## - attr(*, &quot;class&quot;)= chr &quot;xml_node&quot; child1 ## {xml_node} ## &lt;Activities&gt; ## [1] &lt;Activity Sport=&quot;Running&quot;&gt;\\n &lt;Id&gt;2010-05-04T22:37:00&lt;/Id&gt;\\n &lt;Lap S ... child2 &lt;- xml_child(rootnode, 2) child2 ## {xml_node} ## &lt;Author type=&quot;Application_t&quot;&gt; ## [1] &lt;Name&gt;Smashrun&lt;/Name&gt; ## [2] &lt;Build&gt;\\n &lt;Version&gt;\\n &lt;VersionMajor&gt;8&lt;/VersionMajor&gt;\\n &lt;Versi ... Seuls les éléments Lap (1 Lap par activité) et Track (liste de geolocations) semblent être disponibles noeud Activities 3.0.2 Vérification que l’ensemble des fichiers reflètent cette même structure Exploration des éléments / (racine) Le premier exemple montre un fichier contenant uniquement deux éléments (parmi d’autres tels que Folders, Workouts, Courses, Extensions): Author Activities setwd(DATASET_DIRECTORY) ##for (i in 1:length(file_list)) { ##for (i in 1:10) { i &lt;- 1 ## fileName &lt;- file_list[i] fileName &lt;- &quot;smashrun-2017-09-30-11142058.tcx&quot; out &lt;- readLines(fileName, n=-1) # read all the lines of the file into a vector of characters out1 &lt;- str_c(out, collapse = &quot;&quot;) # concatenate all the lines into one line out2 &lt;- read_xml(out1, as_html = FALSE, options = c(&quot;NOBLANKS&quot;,&quot;RECOVER&quot;), verbose=TRUE) rootnode &lt;- xml_root(out2) rootsize &lt;- xml_length(rootnode) # Find number of nodes in the root. for (ii in 1:rootsize) { child &lt;- xml_child(rootnode, ii) # lit chaque élément disponible sous la racine du document XML name &lt;- xml_name(child) # récupère le nom de l&#39;élément size &lt;- xml_length(child) # ainsi que le nombre d&#39;éléments contenus rowDf &lt;- data.frame(fileName = fileName, childName = name, childEntries = size) if (i == 1 &amp;&amp; ii == 1) df &lt;- rowDf else df &lt;- rbind(df, rowDf) } ##} df %&gt;% group_by(childName) %&gt;% summarise(min = min(childEntries), max = max(childEntries)) ## # A tibble: 2 x 3 ## childName min max ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Activities 1 1 ## 2 Author 2 2 Donc on voit que l’élément /Activities n’a jamais plus d’une occurrance d’activité dans nos données. Author à toujours 2 éléments : /Author/Name et /Author/Build correspondant à l’application SmashRun (pas vraiment d’interêt) Exploration de l’élément /Activities/Activity setwd(DATASET_DIRECTORY) ##for (i in 1:length(file_list)) { for (i in 1:10) { ##i &lt;- 1 fileName &lt;- file_list[i] ##fileName &lt;- &quot;smashrun-2017-09-30-11142058.tcx&quot; out &lt;- readLines(fileName, n=-1) # read all the lines of the file into a vector of characters out1 &lt;- str_c(out, collapse = &quot;&quot;) # concatenate all the lines into one line out2 &lt;- read_xml(out1, as_html = FALSE, options = c(&quot;NOBLANKS&quot;,&quot;RECOVER&quot;), verbose=TRUE) rootnode &lt;- xml_root(out2) rootsize &lt;- xml_length(rootnode) # Find number of nodes in the root. for (ii in 1:rootsize) { childRoot &lt;- xml_child(rootnode, ii) # lit chaque élément disponible sous la racine du document XML nameRoot &lt;- xml_name(childRoot) # récupère le nom de l&#39;élément if (nameRoot == &quot;Activities&quot;) { childActivity &lt;- xml_child(childRoot) # on sait qu&#39;il n&#39;y a qu&#39;une seule entrée Activities par document sizeActivity &lt;- xml_length(childActivity) for (iii in 1:sizeActivity) { child &lt;- xml_child(childActivity, iii) # lit chaque élément disponible de l&#39;élément Activity size &lt;- xml_length(child) # ainsi que le nombre d&#39;éléments contenus name &lt;- xml_name(child) # récupère le nom de l&#39;élément attributs &lt;- str_c(&quot;&quot;, xml_attrs(child)) #print(attributs) rowDf &lt;- data.frame(fileName = fileName, childName = name, childEntries = size, childAttr = attributs) if (i == 1 &amp;&amp; iii == 1) dfActivities &lt;- rowDf else dfActivities &lt;- rbind(dfActivities, rowDf) } } } } dfActivities %&gt;% group_by(fileName, childName) %&gt;% summarise(n = n()) %&gt;% group_by(childName, fileName) %&gt;% summarise(n = sum(n)) %&gt;% group_by(childName) %&gt;% summarise(min = min(n), max = max(n)) ## # A tibble: 3 x 3 ## childName min max ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Id 1 1 ## 2 Lap 1 11 ## 3 Notes 1 1 Lorsqu’un Lap n’a qu’une seule occurrence il s’agit d’une saisie manuelle de l’entrainement et donc il ne devrait pas y avoir de tracking associé (élément /Activities/Activity/Lap/Track absent) dfActivities %&gt;% filter(childName == &quot;Lap&quot;) %&gt;% group_by(fileName) %&gt;% summarise(n = n()) %&gt;% ungroup() ## # A tibble: 10 x 2 ## fileName n ## &lt;fct&gt; &lt;int&gt; ## 1 smashrun-2010-05-04-11092860.tcx 1 ## 2 smashrun-2010-05-06-11092861.tcx 9 ## 3 smashrun-2010-05-08-11092862.tcx 6 ## 4 smashrun-2010-05-10-11092863.tcx 1 ## 5 smashrun-2010-05-13-11092864.tcx 1 ## 6 smashrun-2010-05-15-11092865.tcx 4 ## 7 smashrun-2010-05-16-11092866.tcx 5 ## 8 smashrun-2010-05-18-11092867.tcx 1 ## 9 smashrun-2010-05-21-11092868.tcx 3 ## 10 smashrun-2010-05-23-11092869.tcx 11 #filter(n == 1) exploration du contenu des attributs pour les éléments vides /Activities/Activity/Id et /Activities/Activity/Notes dfActivities %&gt;% filter(childName == &quot;Notes&quot; &amp; childAttr != &quot;&quot;) ## [1] fileName childName childEntries childAttr ## &lt;0 rows&gt; (or 0-length row.names) dfActivities %&gt;% filter(childName == &quot;Id&quot; &amp; childAttr != &quot;&quot;) ## [1] fileName childName childEntries childAttr ## &lt;0 rows&gt; (or 0-length row.names) Exploration de l’élément /Activities/Activity/Lap Lap(s) du fichier smashrun-2010-05-06-11092861.tcx Il semble que, par défaut, un lap corresponde à 1 km et l’attribut Id correspond par défaut au ts de début du lap disponible au niveau de l’attribut StartTime de l’élément Lap. Exploration de l’élément /Activities/Activity/Lap/Track 3.0.3 Lecture de l’ensemble des données (format tidy) Dans un premier temps on "],
["text-mining.html", "Chapter 4 text mining 4.1 Occurence of words", " Chapter 4 text mining knitr::opts_chunk$set(warning=FALSE, message=FALSE, include=TRUE) DATASET_DIRECTORY &lt;- &quot;/DATASETS/job_posting_cleansed/&quot; 4.1 Occurence of words This notebook provides a good example of how we can apply some basic functions from the package https://www.tidytextmining.com/tidytext.html in order to quantify and compare the text of job positions. Here we picked a sample of 10 job offers posted on the web for two type of positions: data analyst and data scientist. Some of the descriptions were only available in french therefore I transltated the others from english to french using google translate. 4.1.1 Proof of concept notes about Tidytext with french content The Tidytext package does not implement directly all the features to interpret the ’ character in french. This was about to be implemented but finally Julia decided to not move forward with the idea (https://github.com/juliasilge/tidytext/pull/89). As an alternative she propose to use string functions prior to call unnest_tokens. This is far from being perfect (because it split words like aujourd’hui, prud’hommes, etc) as explained by Colin Fay (https://github.com/juliasilge/tidytext/pull/89#issuecomment-354409107). Colin provides a package (https://github.com/ColinFay/proustr) which may implement something similar but I have not looked in depth. d &lt;- tibble::tibble(txt = c(&quot;C&#39;est l&#39;arriere-cuisine. On s&#39;y trouve. J&#39;ai rdv aujourd&#39;hui au tribunal des prud&#39;hommes&quot;)) d &lt;- d %&gt;% mutate(newtext = str_replace_all(txt, &quot;[:punct:]&quot;, &quot; &quot;)) # issue with aujourd&#39;hui &amp; prod&#39;hommes which are split output &lt;- unnest_tokens(d, word, newtext) sw &lt;- get_stopwords(language = &quot;fr&quot;) output %&gt;% anti_join(sw) ## # A tibble: 9 x 2 ## txt word ## &lt;chr&gt; &lt;chr&gt; ## 1 C&#39;est l&#39;arriere-cuisine. On s&#39;y trouve. J&#39;ai rdv aujourd&#39;hui au ~ arriere ## 2 C&#39;est l&#39;arriere-cuisine. On s&#39;y trouve. J&#39;ai rdv aujourd&#39;hui au ~ cuisine ## 3 C&#39;est l&#39;arriere-cuisine. On s&#39;y trouve. J&#39;ai rdv aujourd&#39;hui au ~ trouve ## 4 C&#39;est l&#39;arriere-cuisine. On s&#39;y trouve. J&#39;ai rdv aujourd&#39;hui au ~ rdv ## 5 C&#39;est l&#39;arriere-cuisine. On s&#39;y trouve. J&#39;ai rdv aujourd&#39;hui au ~ aujourd ## 6 C&#39;est l&#39;arriere-cuisine. On s&#39;y trouve. J&#39;ai rdv aujourd&#39;hui au ~ hui ## 7 C&#39;est l&#39;arriere-cuisine. On s&#39;y trouve. J&#39;ai rdv aujourd&#39;hui au ~ tribun~ ## 8 C&#39;est l&#39;arriere-cuisine. On s&#39;y trouve. J&#39;ai rdv aujourd&#39;hui au ~ prud ## 9 C&#39;est l&#39;arriere-cuisine. On s&#39;y trouve. J&#39;ai rdv aujourd&#39;hui au ~ hommes La source de données originale se trouve à : “/Users/Yannick/Google Drive/Services Right Management/CV - Resumé/étape 1 - recherche du poste visé/CLEANSED” setwd(DATASET_DIRECTORY) file_list &lt;- dir() file_list ## [1] &quot;Analyste - Science des données de fiabilité - Exo.txt&quot; ## [2] &quot;Analyste des données - Scientifique des données - FinDev Canada.txt&quot; ## [3] &quot;Analyste données clients - Aimia.txt&quot; ## [4] &quot;Data Analyst - MindGeek .txt&quot; ## [5] &quot;Data Scientist - ExPretio.txt&quot; ## [6] &quot;Marketing Analyst - DavidsTea.txt&quot; ## [7] &quot;Scientifique de données - Aviva.txt&quot; ## [8] &quot;scientifique des données - Sun Life Financial.txt&quot; ## [9] &quot;Scientifiques de données – Analytique Clients - Banque Nationale.txt&quot; ## [10] &quot;Scientifiques des données juniors - Ericsson.txt&quot; 4.1.2 pattern matching to extract the position and the company name resume_df &lt;- data_frame(filename = str_to_lower(file_list)) companyPattern = &#39;- ([^-]*).txt$&#39; # starting from the end of the string, look for the last &#39;-&#39; and following characters which contain the company name str_view(resume_df$filename, companyPattern) # check the matching pattern companies &lt;- str_trim(str_match(resume_df$filename, companyPattern)[,2]) # matches the pattern and retrieve only the group capture positionPattern = &#39;(scien|analy)&#39; # maches any of the first word containing eitehr scien (for data science) or analy (for data analyst) str_view(resume_df$filename, positionPattern) positions &lt;- str_match(resume_df$filename, positionPattern)[,2] 4.1.3 Ingest &amp; transform all the files using tidytext setwd(DATASET_DIRECTORY) stopWordsForFrench &lt;- get_stopwords(language = &quot;fr&quot;) for (i in 1:length(file_list)) { temp_text &lt;- read_lines(file_list[i]) text1 &lt;- str_replace_all(temp_text, &quot;[:punct:]&quot;, &quot; &quot;) temp_df &lt;- data_frame(text = text1, company = companies[i], position = positions[i]) output &lt;- unnest_tokens(temp_df, word, text) output1 &lt;- output %&gt;% anti_join(stopWordsForFrench) if (i == 1) df &lt;- output1 else df &lt;- rbind(df, output1) } 4.1.4 Visualization - global df %&gt;% count(word, sort = TRUE) %&gt;% filter(n &gt; 10) %&gt;% mutate(word = reorder(word, n)) %&gt;% ggplot(aes(word, n)) + geom_col() + xlab(NULL) + coord_flip() df %&gt;% count(word) %&gt;% with(wordcloud(word, n, max.words = 20)) 4.1.5 Analysis by position Analyst vs Data scientist df %&gt;% group_by(position, word) %&gt;% summarise(n = n()) %&gt;% filter(n &gt; 8) %&gt;% ungroup() %&gt;% # if we do not do that the reorder function does not work mutate(word = reorder(word, n)) %&gt;% ggplot(aes(word, n, fill = position)) + geom_col(show.legend = FALSE) + facet_wrap(~position, scales = &quot;free_y&quot;) + labs(y = &quot;occurrences of the word in the job description&quot;, x = NULL) + coord_flip() "]
]
